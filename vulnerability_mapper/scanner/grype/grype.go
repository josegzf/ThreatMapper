package grype

import (
	"encoding/json"
	"github.com/adrg/xdg"
	"github.com/anchore/grype/grype"
	"github.com/anchore/grype/grype/db"
	grypeMatch "github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/presenter/models"
	"github.com/anchore/syft/syft/source"
	"github.com/deepfence/package-scanner/util"
	"github.com/deepfence/vulnerability_mapper/scanner"
	"github.com/deepfence/vulnerability_mapper/utils"
	"github.com/pkg/errors"
	"path"
	"strings"
)

const (
	RubyGemMatcher    string = "ruby-gem-matcher"
	JavaMatcher       string = "java-matcher"
	PythonMatcher     string = "python-matcher"
	JavascriptMatcher string = "javascript-matcher"
	MsrcMatcher       string = "msrc-matcher" //dotnet
	DBUpdateURL              = "https://toolbox-data.anchore.io/grype/databases/listing.json"
)

var (
	dbConfig db.Config
)

func init() {
	dbConfig = db.Config{
		DBRootDir:           path.Join(xdg.CacheHome, "grype", "db"),
		ListingURL:          DBUpdateURL,
		CACert:              "",
		ValidateByHashOnGet: false,
	}
}

func PopulateFinalReport(sbomBytes []byte, c util.Config) (string, error) {
	var cveJsonList string

	var sbom util.Sbom
	err := json.Unmarshal(sbomBytes, &sbom)
	if err != nil {
		return "", err
	}

	provider, metadataProvider, dbStatus, err := grype.LoadVulnerabilityDB(dbConfig, false)
	if err != nil {
		return "", err
	}
	matches := grype.FindVulnerabilitiesForPackage(provider, sbom.Context.Distro, sbom.Packages...)
	var appConfig interface{}
	grypeDocument, err := models.NewDocument(sbom.Packages, sbom.Context, matches, []grypeMatch.IgnoredMatch{}, metadataProvider, appConfig, dbStatus)
	if err != nil {
		return "", err
	}

	for _, match := range grypeDocument.Matches {
		description := match.Vulnerability.Description
		if description == "" {
			relatedVulnerabilities := match.RelatedVulnerabilities
			if len(relatedVulnerabilities) > 0 {
				description = relatedVulnerabilities[0].Description
			}
		}
		cveFixedInVersionList := match.Vulnerability.Fix.Versions
		cveFixedInVersion := ""
		if len(cveFixedInVersionList) != 0 {
			cveFixedInVersion = cveFixedInVersionList[0]
		}
		cveCVSSScoreList := match.Vulnerability.Cvss
		var cvssScore float64
		var overallScore float64
		var attackVector string
		if len(cveCVSSScoreList) == 0 {
			if len(match.RelatedVulnerabilities) > 0 {
				cvssScore, overallScore, attackVector = GetCvss(match.RelatedVulnerabilities[0].Cvss)
			}
		}

		report := scanner.VulnerabilityScanReport{
			Type:                   "cve",
			Masked:                 "false",
			Host:                   c.HostName,
			NodeType:               c.NodeType,
			NodeId:                 c.NodeId,
			HostName:               c.HostName,
			KubernetesClusterName:  c.KubernetesClusterName,
			ScanId:                 c.ScanId,
			CveId:                  match.Vulnerability.ID,
			CveType:                getLanguageFromMatcher(match.MatchDetails[0].Matcher),
			CveContainerImage:      c.NodeId,
			CveContainerImageId:    c.ImageId,
			CveContainerName:       c.ContainerName,
			CveSeverity:            strings.ToLower(match.Vulnerability.Severity),
			CveCausedByPackage:     match.Artifact.Name + "_" + match.Artifact.Version,
			CveCausedByPackagePath: combinePaths(match.Artifact.Locations),
			CveContainerLayer:      "",
			CveFixedIn:             cveFixedInVersion,
			CveLink:                match.Vulnerability.DataSource,
			CveDescription:         description,
			CveCvssScore:           cvssScore,
			CveOverallScore:        overallScore,
			CveAttackVector:        attackVector,
		}
		dfVulnerabilitiesStr, err := json.Marshal(report)
		if err != nil {
			return "", errors.Wrap(err, "failed to marshal vulnerability report")
		}
		if err == nil && string(dfVulnerabilitiesStr) != "" {
			cveJsonList += string(dfVulnerabilitiesStr) + ","
		}
	}

	return cveJsonList, nil
}

func getLanguageFromMatcher(matcher string) string {
	var MatcherToLanguage map[string]string = map[string]string{
		RubyGemMatcher:    "ruby",
		JavaMatcher:       "java",
		PythonMatcher:     "python",
		JavascriptMatcher: "js",
		MsrcMatcher:       "dotnet",
	}

	lang := MatcherToLanguage[matcher]
	if lang == "" {
		return "base"
	}
	return lang
}

func combinePaths(paths []source.Coordinates) string {
	var combinedPath string
	for _, path := range paths {
		combinedPath += path.RealPath + ":"
	}
	return utils.TrimSuffix(combinedPath, ":")
}
